\subsection{}

\begin{enumerate}
\item Factory Method: This pattern supports universal polymorphism, since it can return objects of potentially infinitely many derived types. It is a common pattern to avoid calling a constructor of a specific derived type directly. It is better to call a factory than to call a constructor, if the factory should decide which concrete subclass to use, or if additional subclasses may be added to the application in the future. In the example code given, a factory to construct a node from a token (see ex. 7) is given. The returned Node is polymorphic, because it may be an OperatorNode when the supplied token is a string that matches an operator, or a ConstantNode when the supplied token matches a number. It can make use of different kind of model inheritance, depending on the context of the application.
\item Composite: The Operand/Constant tree structure from exercise 7 is an example of the composite pattern. It makes use of a common base class, Node (here: an interface because there are no real attributes shared by all Nodes), a derived composite class (OperatorNode) and a leaf class (ConstantNode). This pattern is useful because it leads to elegant algorithms that can treat the composite element and the leaf element the same (here for example: calling evaluate()). Thus, it is a special case of recursive functional variation inheritance.
\item Template: Functions are declared (and optionally implemented as a default) in an abstract class. Subclasses can overwrite them, if they need to. This pattern is useful, when there is a family of algorithms with the same skeleton, but the steps of the algorithm can be implemented differently (Type of inheritance: Functional variation inheritance). This pattern is the basic principle of a framework: The user of the framework overwrites certain functions with his own implementation. The functions are invoked by the framework when they need to.
\end{enumerate}